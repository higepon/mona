This directory contains the distribution of Scheme Library slib3a4.
Slib conforms to Revised^5 Report on the Algorithmic Language Scheme
and the IEEE P1178 specification.  Slib supports Unix and similar
systems, VMS, and MS-DOS.

The maintainer can be reached at agj @ alum.mit.edu.
	    http://swiss.csail.mit.edu/~jaffer/SLIB.html

			       MANIFEST

  `README' is this file.  It contains a MANIFEST and INSTALLATION
	INSTRUCTIONS.
  `FAQ' Frequently Asked Questions and answers.
  `ChangeLog' documents changes to slib.
  `slib.texi' has documentation on library packages in TexInfo format.

  `Template.scm' Example configuration file.  Copy and customize to
	reflect your system.
  `bigloo.init' is a configuration file for Bigloo.
  `chez.init' is a configuration file for Chez Scheme.
  `DrScheme.init' is a configuration file for DrScheme.
  `elk.init' is a configuration file for ELK 3.0.
  `gambit.init' is a configuration file for Gambit Scheme.
  `macscheme.init' is a configuration file for MacScheme.
  `mitscheme.init' is a configuration file for MIT Scheme.
  `pscheme.init' is configuration file for PocketScheme 0.2.5 (WinCE SIOD)
  `RScheme.init' is a configuration file for RScheme.
  `scheme2c.init' is a configuration file for DEC's scheme->c.
  `scheme48.init' is a configuration file for Scheme48.
  `scsh.init' is a configuration file for Scheme-Shell
  `scm.init' is a configuration file for SCM.
  `t3.init' is a configuration file for T3.1 in Scheme mode.
  `STk.init' is a configuration file for STk.
  `umbscheme.init' is a configuration file for umb-scheme.
  `vscm.init' is a configuration file for VSCM.
  `guile.init' is a configuration file for guile.
  `jscheme.init' is a configuration file for JScheme.
  `mklibcat.scm' builds the *catalog* cache.
  `require.scm' has code which allows system independent access to
	the library files.

  `slib.sh' is a shell script for running various Schemes with SLIB.
  `Bev2slib.scm' Converts Stephen Bevan's "*.map" files to SLIB catalog entries.
  `pp.scm' has pretty-print.
  `ppfile.scm' has pprint-file and pprint-filter-file.
  `obj2str.scm' has object->string.
  `strcase.scm' has functions for manipulating the case of strings.
  `genwrite.scm' has a generic-write which is used by pp.scm,
	pp2str.scm and obj2str.scm
  `format.scm' has Common-Lisp format.
  `formatst.scm' tests format.
  `printf.scm' has printf, fprintf, and sprintf compatible with C.
  `scanf.scm' has scanf, fscanf, and sscanf compatible by C.
  `lineio' has line oriented input/output functions.
  `qp.scm' has printer safe for circular structures.
  `break.scm' has break and continue.
  `trace.scm' has trace and untrace for tracing function execution.
  `debug.scm' has handy higher level debugging aids.
  `strport.scm' has routines for string-ports.
  `strsrch.scm' search for chars or substrings in strings and ports.
  `differ.scm' An O(NP) Sequence Comparison Algorithm.

  `alist.scm' has functions accessing and modifying association lists.
  `hash.scm' defines hash, hashq, and hashv.
  `hashtab.scm' has hash tables.
  `sierpinski.scm' 2-dimensional coordinate hash.
  `phil-spc.scm' Hilbert Space-Filling Curve.
  `peanosfc.scm' Peano Space-Filling Curve.
  `soundex.scm' English name hash.
  `logical.scm' emulates 2's complement logical operations.
  `random.scm' has random number generator compatible with Common Lisp.
  `randinex.scm' has inexact real number distributions.
  `primes.scm' has primes and probably-prime?.
  `factor.scm' has factor.
  `root.scm' has Newton's and Laguerre's methods for finding roots.
  `minimize.scm' has Golden Section Search for minimum value.
  `limit.scm' computes one-sided limits.
  `cring.scm' extend + and * to custom commutative rings.
  `selfset.scm' sets single letter identifiers to their symbols.
  `determ.scm' compute determinant of list of lists.
  `charplot.scm' has procedure for plotting on character screens.
  `grapheps.scm' has procedures for creating PostScript graphs.
  `grapheps.ps' is PostScript runtime support for creating graphs.
  `matfile.scm' reads MAT-File Format version 4 (MATLAB).
  `solid.scm' has VRML97 solid-modeling.
  `colorspc.scm' has CIE and sRGB color transforms.
  `colornam.scm' has color-name database functions.
  `mkclrnam.scm' creates color-name databases.
  `color.scm' has color data-type.
  `cie1931.xyz' CIE XYZ(1931) Spectra from 380.nm to 780.nm.
  `cie1964.xyz' CIE XYZ(1964) Spectra from 380.nm to 780.nm.
  `ciesia.dat' CIE Standard Illuminant A relative spectral power distribution
  `ciesid65.dat' CIE Standard Illuminant D65 relative spectral power distribution
  `daylight.scm' Model of sky colors.
  `getopt.scm' has posix-like getopt for parsing command line arguments.
  `timecore.scm' has shared time conversion routines.
  `psxtime.scm' has Posix time conversion routines.
  `cltime.scm' has Common-Lisp time conversion routines.
  `timezone.scm' has the default time-zone, UTC.
  `tzfile.scm' reads sysV style (binary) timezone file.
  `comparse.scm' has shell-like command parsing.

  `rdms.scm' has code to construct a relational database from a base
	table implementation.
  `alistab.scm' has association list base tables.
  `dbutil.scm' has procedures for creating and opening relational
	databases.
  `dbsyn.scm' has Syntactic extensions for RDMS (within-database).
  `dbcom.scm' embeds *commands* in relational databases.
  `dbinterp.scm' Interpolate function from database table.
  `htmlform.scm' generates HTML-3.2 with forms.
  `db2html.scm' convert relational database to hyperlinked tables and
	pages.
  `http-cgi.scm' serves WWW pages with HTTP or CGI.
  `html4each.scm' parses HTML files.
  `dirs.scm' maps over directory filenames.
  `uri.scm' encodes and decodes Uniform Resource Identifiers.
  `dbrowse.scm' browses relational databases.
  `paramlst.scm' has procedures for passing parameters by name.
  `getparam.scm' has procedures for converting getopt to parameters.
  `manifest.scm' List SLIB module requires and exports; useful for compiling.
  `top-defs.scm' Finds external references.
  `vet.scm' Checks each module imports, exports, and documentation.
  `schmooz.scm' is a simple, lightweight markup language for
	interspersing Texinfo documentation with Scheme source code.
  `glob.scm' has filename matching and manipulation.
  `batch.scm' Group and execute commands on various operating systems.
  `crc.scm' Calculate POSIX.2 checksums and other CRCs.

  `record.scm' a MITScheme user-definable datatypes package
  `promise.scm' has code from R4RS for supporting DELAY and FORCE.

  `repl.scm' has a read-eval-print-loop.
  `defmacex.scm' has defmacro:expand*.
  `mbe.scm' has "Macro by Example" define-syntax.
  `scmacro.scm' is a syntactic closure R4RS macro package.
	r4rsyn.scm, synclo.scm, synrul.scm have syntax definitions
	and support.
  `scmactst.scm' is code for testing SYNTACTIC CLOSURE macros.
  `scainit.scm' is a syntax-case R4RS macro package.
	scaglob.scm scamacr.scm scaoutp.scm scaexpp.scm have
	syntax definitions and support.  `syncase.sh' is a shell
	script for producing the SLIB version from the original.
  `macwork.scm' is a "Macros that work" package.
	mwexpand.scm mwdenote.scm mwsynrul.scm have support.
  `macrotst.scm' is code from R4RS for testing macros.

  `values.scm' is multiple values.
  `queue.scm' has queues and stacks.

  `object.scm' is an object system.
  `yasyn.scm' defines (syntax-rules) macros for object oriented programming.
  `collect.scm' is collection operators (like CL sequences).
  `priorque.scm' has code and documentation for priority queues.
  `wttree.scm' has weight-balanced trees.
  `wttest.scm' tests weight-balanced trees.
  `process.scm' has multi-processing primitives.
  `array.scm' has multi-dimensional arrays.
  `subarray.scm' has subarray and accessory procedures.
  `linterp.scm' has interpolate-array-ref and resample-array!.
  `arraymap.scm' has array-map!, array-for-each, and array-indexes.

  `sort.scm' has sorted?, sort, sort!, merge, and merge!.
  `tsort.scm' has topological-sort.
  `comlist.scm' has many common list and mapping procedures.
  `tree.scm' has functions dealing with trees.
  `coerce.scm' has coerce and type-of from Common-Lisp.
  `chap.scm' has functions which compare and create strings in
	"chapter order".

  `sc4opt.scm' has optional rev4 procedures.
  `sc4sc3.scm' has procedures to make a rev3 implementation run rev4
	code.
  `sc2.scm' has rev2 procedures eliminated in subsequent versions.
  `mularg.scm' redefines - and / to take more than 2 arguments.
  `mulapply.scm' redefines apply to take more than 2 arguments.
  `ratize.scm' has function rationalize from Revised^4 spec.
  `trnscrpt.scm' has transcript-on and transcript-off from Revised^4 spec.
  `withfile.scm' has with-input-from-file and with-output-to-file from R4RS.
  `dynwind.scm' has dynamic-wind from R5RS.
  `eval.scm' has eval with environments from R5RS.
  `dwindtst.scm' has routines for characterizing dynamic-wind.
  `dynamic.scm' has DYNAMIC data type [obsolete].
  `fluidlet.scm' has fluid-let syntax.
  `structure.scm' has undocumented syntax-case macros.
  `byte.scm' has arrays of small integers.
  `bytenumb.scm' convert byte-arrays to integers; IEEE floating-point numbers.
  `transact.scm' File locking and backup.
  `pnm.scm' provides a Scheme interface to "portable bitmap" files.
  `simetrix.scm' provides SI Metric Interchange Format.
  `ncbi-dna.scm' reads and manipulates DNA and protein sequences.
  `srfi.scm' implements Scheme Request for Implementation.
  `srfi-N.scm' implements srfi-N.

		      INSTALLATION INSTRUCTIONS

  There are four parts to installation:

   * Unpack the SLIB distribution.

   * Configure the Scheme implementation(s) to locate the SLIB
     directory.

   * Arrange for Scheme implementation to load its SLIB initialization
     file.

   * Build the SLIB catalog for the Scheme implementation.

Unpacking the SLIB Distribution
-------------------------------

If the SLIB distribution is a Linux RPM, it will create the SLIB
directory `/usr/share/slib'.

  If the SLIB distribution is a ZIP file, unzip the distribution to
create the SLIB directory.  Locate this `slib' directory either in your
home directory (if only you will use this SLIB installation); or put it
in a location where libraries reside on your system.  On unix systems
this might be `/usr/share/slib', `/usr/local/lib/slib', or
`/usr/lib/slib'.  If you know where SLIB should go on other platforms,
please inform agj @ alum.mit.edu.

Configure Scheme Implementation to Locate SLIB
----------------------------------------------

If the Scheme implementation supports `getenv', then the value of the
shell environment variable SCHEME_LIBRARY_PATH will be used for
`(library-vicinity)' if it is defined.  Currently, Chez, Elk,
MITScheme, scheme->c, VSCM, and SCM support `getenv'.  Scheme48
supports `getenv' but does not use it for determining
`library-vicinity'.  (That is done from the Makefile.)

  The `(library-vicinity)' can also be specified from the SLIB
initialization file or by implementation-specific means.

Loading SLIB Initialization File
--------------------------------

Check the manifest in `README' to find a configuration file for your
Scheme implementation.  Initialization files for most IEEE P1178
compliant Scheme Implementations are included with this distribution.

  You should check the definitions of `software-type',
`scheme-implementation-version', `implementation-vicinity', and
`library-vicinity' in the initialization file.  There are comments in
the file for how to configure it.

  Once this is done, modify the startup file for your Scheme
implementation to `load' this initialization file.

Build New SLIB Catalog for Implementation
-----------------------------------------

When SLIB is first used from an implementation, a file named `slibcat'
is written to the `implementation-vicinity' for that implementation.
Because users may lack permission to write in
`implementation-vicinity', it is good practice to build the new catalog
when installing SLIB.

  To build (or rebuild) the catalog, start the Scheme implementation
(with SLIB), then:

     (require 'new-catalog)

  The catalog also supports color-name dictionaries.  With an
SLIB-installed scheme implementation, type:
     (require 'color-names)
     (make-slib-color-name-db)
     (require 'new-catalog)
     (slib:exit)

Implementation-specific Instructions
------------------------------------

Multiple implementations of Scheme can all use the same SLIB directory.
Simply configure each implementation's initialization file as outlined
above.

 - Implementation: SCM
     The SCM implementation does not require any initialization file as
     SLIB support is already built into SCM.  See the documentation
     with SCM for installation instructions.

 - Implementation: VSCM
     From: Matthias Blume <blume @ cs.Princeton.EDU>
     Date: Tue, 1 Mar 1994 11:42:31 -0500

     Disclaimer: The code below is only a quick hack.  If I find some
     time to spare I might get around to make some more things work.

     You have to provide `vscm.init' as an explicit command line
     argument.  Since this is not very nice I would recommend the
     following installation procedure:

       1. run scheme

       2. `(load "vscm.init")'

       3. `(slib:dump "dumpfile")'

       4. mv dumpfile place-where-vscm-standard-bootfile-resides e.g.
          mv dumpfile /usr/local/vscm/lib/scheme-boot (In this case
          vscm should have been compiled with flag
          -DDEFAULT_BOOTFILE='"/usr/local/vscm/lib/scheme-boot"'.  See
          Makefile (definition of DDP) for details.)


 - Implementation: Scheme48
     To make a Scheme48 image for an installation under `<prefix>',

       1. `cd' to the SLIB directory

       2. type `make prefix=<prefix> slib48'.

       3. To install the image, type `make prefix=<prefix> install48'.
          This will also create a shell script with the name `slib48'
          which will invoke the saved image.

 - Implementation: PLT Scheme
 - Implementation: DrScheme
 - Implementation: MzScheme
     The `init.ss' file in the _slibinit_ collection is an SLIB
     initialization file.

     To use SLIB in MzScheme, set the SCHEME_LIBRARY_PATH environment
     variable to the installed SLIB location; then invoke MzScheme thus:

     `mzscheme -f ${SCHEME_LIBRARY_PATH}DrScheme.init'

 - Implementation: MIT Scheme
     `scheme -load ${SCHEME_LIBRARY_PATH}mitscheme.init'

 - Implementation: Guile
     `guile -l ${SCHEME_LIBRARY_PATH}guile.init'

			 PORTING INSTRUCTIONS

If there is no initialization file for your Scheme implementation, you
will have to create one.  Your Scheme implementation must be largely
compliant with
  `IEEE Std 1178-1990',
  `Revised(4) Report on the Algorithmic Language Scheme', or
  `Revised(5) Report on the Algorithmic Language Scheme'
in order to support SLIB.

  `Template.scm' is an example configuration file.  The comments inside
will direct you on how to customize it to reflect your system.  Give
your new initialization file the implementation's name with `.init'
appended.  For instance, if you were porting `foo-scheme' then the
initialization file might be called `foo.init'.

  Your customized version should then be loaded as part of your scheme
implementation's initialization.  It will load `require.scm' from the
library; this will allow the use of `provide', `provided?', and
`require' along with the "vicinity" functions.  The rest of the
library will then be accessible in a system independent fashion.

  Please mail new working configuration files to `agj @ alum.mit.edu'
so that they can be included in the SLIB distribution.

			      USING SLIB

  All library packages are written in IEEE P1178 Scheme and assume
that a configuration file and `require.scm' package have already been
loaded.  Other versions of Scheme can be supported in library packages
as well by using, for example, `(provided? 'r3rs)' or `(require 'r3rs)'.

The first chapter of the SLIB manual "The Library System" explains the
mechanics of using SLIB modules.

	      http://swiss.csail.mit.edu/~jaffer/slib_1
